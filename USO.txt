
alt + sageata stanga
ctrl + acolada

## https://onceupon.github.io/Bash-Oneliner/
## https://www.bashoneliners.com/


--ALTELE--
userls -Rl                          -> afisare detaliata si recursiva
ln -s {nume_fisier} {denumire}			-> asociez unei cai un nume, creeez link/legatura
alias {nume_dat_de_mine}="{comanda}"		-> asociez unei comenzi un nume, creez alias
unalias {nume_alias}                        -> stergere completa alias  
echo $?						-> afiseaza 0, daca ult comanda a avut succes
wc -l                       -> afiseaza nr de linii
tldr {expresie/comanda}				-> man dar mai pe scurt
last -{numar}					-> afiseaza ultimele {numar} logari
mkfs {nume_disc}                -> formateaza un nume_disc
free                            -> afiseaza memoria libera
history                         -> afiseaza intreg istoricul de comenzi
!!                              -> folosire comanda anterioara
Ctr + r                         -> cautare recursiva in istoric




--FILES--
sudo pentru acces garantat
cd {cale_fisier}                ->schimbare director
cd -                            -> revenire la directorul anterior
file stat {nume_fisier}                      -> afisare metadate fisier
ls -hairls                                  -> multe informatii despre fisiere
ls -ld                          -> afiseaza doar directoarele
touch {nume_fisier}, > {nume_fisier}                -> creeaza fisier
cp -r {sursa} {destiantie}             ->copiere recursica fisiere
mv {fisier_sursa} {fisir_destinatie}                -> mutare/redenumire fisier
cmp {fisier1} {fisier2}                 -> compare byte cu byte un fisier
cat {fisier}                            -> afisare continut fisier
rm -rf  {nume_fisiere}              -> stergere recursiva si fortata fisiere/folder
                                                !! mare atentie la stergerea recursiva
locate {fisier}                           -> localizeaza fisiere strict dupa nume
find {calea_catre_fisier} -name "nume" -type {f,l,d} -size +/-1024k    
                                    -> cauta un fisier intr-o cale dupa nume, tip si dimensiune
whereis, which, type                -> informatii depre comenzi
                        whereis ls
                        which ls
                        type ls     -> recomandat pentru alias-uri
./program < fisier_intrare                 -> preia outputul din fisier
./program > fisiere_de_iesire              -> duce outputul in fisier
./program 2> fis, ier_erori                -> redirectare erori in fisiserele
./program 2>& 1                            -> redirectare erori catre iesirea standard
./program; >> fisier                        -> adaugare in continuarea fisierului
(comanda ; comanda ; ..) > fisier           -> redirectarea tuturor comenzilor intr-un fisier   
                                            EX: ( ls ; ps ) > a.out




--PERMISSIONS--
chown {utilizator} {fisier} 			-> permisiune fisier utilizatori
chgpr {utilizator} {fisier} 			-> permisiune fisier grup
chmod +/-[rwx] {file}				-> adaugare/stergere o permisiune fisier catre utilizator curent
chmod {nr1nr2nr3} {file}			-> adaugare permisiuni; nr1, nr2, nr3 = numere care in binar 
						   reprezinta permisiuni in urm ord: user, group, others

owner,group,others
--- --- --- 
r = 4
w = 2
x = 1 


--USER--
finger/pinky {utilizator}				-> aflare detalii despre acel utilizator
id {utilizator}                 -> informatii utilizator
users, w, who {utilizator}         -> utilizatorii autentificati in sistem acum
sudo su {utilizator}             -> schimba utilizatorul in cel specificat
sudo useradd -m -d {home_directory} {user}	-> creez utilizator nou cu tot si setez directorul home
sudo adduser {user}				-> adaugare user 
sudo deluser {user}				-> delete user
sudo addgroup {group}				-> adaugare grup
id {user}				    	-> verificare id user 
su {user}				    	-> schimbare user
passwd {user} 					    -> schimbare parola user
chsh                                      -> schimbare shell de login 
sudo usermod {user} -s {cale shell} 	        	-> schimbare shell default pentru un utilizator
sudo usermod {user} -G {grup}			            -> adaugare user intr-un grup
sudo usermod -a -G {grup1,grup2,etc}		    	-> adaugare user curent in mai multe grupuri
sudo usermod -d {cale_fisier} {user}	        	-> schimbare director  pentru user
sudo usermod --expiredate 1  {utilizator}           -> dezactiveaza contul si nu mai poate fi folosit
 

--ARHIVARE/DEZARHIVARE--
sudo tar -cvjSf {nume}.tar.bz2 {cale_folder} 	-> arhivare foler in arhiva de tipul .tar.bz2
zip -r archivename.zip directory_name		-> arhivare director in zip
zip myfile.zip filename.txt			-> arhivare folder in zip
tar -cvf {nume}.tar {fisiere_de_arhivat}       ->arhiveaza tip tar fisiserele
tar --append --file={arhiva}.tar {file}		-> append file la o arhiva
tar -tf {archive}.tar				-> pentru a vedea continutul arhivei
tar -xf {cale_arhiva}.tar			-> pentru dezarhivare



--GLOBBING--
grep -n {pattern} {cale}			-> afiseaza nr liniei care contine patternul cautat
grep -v {pattern} {cale}			-> afiseaza toate liniile mai putin cele care contin pattern
cut -d'{delimitator(:,..)}' -f{nr_col1},{nr_col2}-> extrage informatii pe linii si coloane
tr "ceva" "altceva"				-> inlocuieste "ceva" cu "altceva"
sed 's/ceva/altceva/g' {file}			-> inlocuieste "ceva" cu "altceva", pe linie (if fara g, atunci tot)
						   foloseste flagul "-i" pentru a inlocui "inplace" 
sed -n {line_m},{line_n}p {cale_fisier}		-> afiseaza liniile din intervalul [m, n]
sort -t	'{separator}' -k {nr_col_infdecaresortam(ex. 3,3)} {file}-> sorteaza (daca vrem sort invers, punem -r)		


--INSTALL--
sudo apt update					-> face update
sudo apt install {pachet}			-> instalare pachet
sudo apt-get install {numele comenzii}		-> instalare comanda
sudo apt search {nume_pachet}               -> cauta un pachet de instalat
apt show {pachet}                           -> afiseaza date despre pachet
sudo apt remove {nume_pachet}               -> dezinstaleaza pachet
sudo apt -d remove {pachet}                 -> descarca pachet fara a-l instalare
sudo pip3 list                              -> afiseaza pachetele instalate local



--IP--
ping -c 4 8.8.8.8				-> verificare internet 
dhclient eth1					-> a obține o adresă IP în mod dinamic pe o interfață
ip address flush eth1				-> a șterge o adresă IP de pe o interfața
ip address show 				-> afisarea adreselor ip 
ip addr add {adresa_ip} dev eth0		-> pentru a atribui o adresa IPv4 unei interfete
ip link set dev eth0 up 			-> pentru a trece interfata eth0 pe UP
ip addr {adresa_IPv4} dev eth0		-> pentru a sterge o adresa IPv4
wget {adresa_pagina_web}				-> pentru a descarca o pagina web
traceroute {adresa_web}                 -> verificare conectivitate placa retea
link set dev {nume_interfata} down/up               -> dezactiveaza/activeaza interfata 
sudo ip address flush                                    orice configurat, ii anterioare ale interfete sunt sterse


--SSH--
scp {cale_fisier} student@10.10.10.3:~/		-> trimiterea fisierelor la distanta prin ssh
scp root@10.10.10.3:/etc/resolv.conf . 		-> descarcarea fisierelor prin ssh in fisierul curent 
scp -r ./Downloads/ root@10.10.10.3:~/ 		-> Comanda anterioară a copiat directorul Downloads și conținutul 
						                    său din directorul curent în directorul home al utilizatorului 
					                        root de la adresa 10.10.10.3
ssh-keygen 					    -> pentru generarea unei perechi de key 

ssh-copy-id root@10.10.10.3			-> Pentru copierea cheii publice pe o stație
ssh-copy-id {nume_user}@vmx.cs.pub.ro    -> adaugarea cheii publice în contul utilizatorului de la distanta
ssh malus@vmx.cs.pub.ro                  -> in urma copierii cheii publice în contul utilizatorului de la distanta,
                                         se poate realiza autentificarea fara parola
ssh -X <username>@fep.grid.pub.ro		-> pentru a ne conecta la o statie
systemctl status {nume_serviciu}		-> afiseaza stare serviciului (ex. ssh, ...)
systemctl start {nume_serviciu}			-> face activ serviciul
systemctl stop {nume_serviciu}			-> face inactiv serviciul


--PROCESE--
ps -ef						            -> afisare procese
ps -o pid,ppid,user,rss,%cpu                 -> afisare procese cu format
pidof {nume_program/proces}			        -> afiseaza pidul programului/procesului
kill -l 				             -> lista comenzilor de "kill"
kill -9	{PID}					           -> BOMBA NUCLEARA PE PROCES
pgrep, pidof, pstree, pmap, lsof, top, htop            -> investigare, urmarire si management procese
mount, lscpu, free, df, lsblk               -> mai multe informatii despre




--SHELL SCRIPTING-- 
sed 's/{ceva}/{altceva}/' text.txt		-> prima aparitie de pe fiecare linie a lui "ceva" este inlocuita 
                                                   cu "altceva" din fisierul text
sed 's/{ceva}/{altceva}/g' text.txt		-> toate aparitiile lui "ceva" sunt inlocuite cu "altceva" din 
                                                   textul dat
sed '/{ceva}/d' text.txt			-> sterge linia care contine "ceva"
cut -d " " -f 1 text.txt			-> afiseaza prima coloana din "text.txt" dupa delimitatorul " " 
seq 						-> genereaza o secvență de numere. Flagul -s este folosit pentru a
                                                   stabili caracterul care delimitează numerele	
wc text.txt					-> echo {numarul de linii}, {numarul de cuvinte}, {numarul de caractere}
$a -eq $b 					-> a egal cu b
$a -gt $b					-> a mai mare ca b
sort 						-> soteaza un fisier (-t specifica separatorul; -k specifica 
                                                   indexul/cheia coloanei, -n sortare numerica; -r sortare inversa)
uniq 						-> selecteaza elementele unice
$* 						-> este un string ($1, $2 … $n) format din toate argumentele 
                                                   primite de script
$@                                              -> este o listă formată din argumentele scriptului
$1, $2 … $n 					-> reprezintă fiecare parametru din script
$0 						-> este numele scriptului
$# 						-> este numărul de argumente primite din linia de comandă
IFS="{separator}" 				-> (Internal Field Separator) definește caracterul sau caracterele 
                                                   care vor fi folosite pentru împărțirea unei linii în câmpuri (splitting).
ps aux | awk '{ print $1 }' | sed '1 d' | sort | uniq | wc 				
                                            -> numarul de utilizatorii de pe sistemul local care au procese pornite.
{nume_variabila}={valoare}                   -> initializare nume_variabila
${variabila}                                -> accesare continut variabila      
unset{nume_variabila}                       -> anuleaza definirea variabilei




--RegEX--
^		-> început de linie
$		-> sfârșit de linie
.		-> orice caracter
*		-> expresia anterioară de oricâte ori, posibil niciodată
+		-> expresia anterioară de oricâte ori, cel puțin o dată
[ajt] 		-> orice caracter din setul de caractere a, j, t
[^ajt]		-> orice caracter mai puțin caracterele a, j, t
|		-> expresia anterioară sau expresia de după (una dintre cele două expresii)
? 		-> expresia anterioară o dată sau niciodată
[a-z]+,[0-9]+                   -> se potrives, cu un nume format din litere mici urmat de virgula si un numar


--ENCODING/HASHING--
echo -n "{text}" | base64			-> encodeaza in base 64
echo -n "{text_encodat}" | base64 -d		-> decodeaza din base 64
echo -n "{text}" | md5sum			-> genereaza hashul
fcrackzip -v -l 1-4 -u secret_brute_force.zip	-> sparge o parola de maxim 4 caractere din secret_brute_force.zip
openssl aes-{nr_biti_cheie}-{mod_de_criptare}
-in {input_file} -out {output_file} 		-> encriptare in AES cu 192 de biti si modul CBC


--GIT-- 
git init				-> creare repository local
git status				-> verificare stare repository 				
git add {fisier}			-> aduagare fisier in staging area
git commit -m "message"
git log					-> verificare istoric comituri
git push origin master
git branch 
git branch {nume_branch} 		-> adaugare branch
git checkout {nume_branch}		-> schimbare branch
git merge {nume_branch}			-> merge intre 2 branchuri